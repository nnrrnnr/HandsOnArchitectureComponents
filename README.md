# HandsOnArchitectureComponents
- https://developer.android.com/topic/libraries/architecture/index.html
- https://riggaroo.co.za/android-architecture-components-looking-room-livedata-part-1/

## 新しいArchitectureComponentsとは何か？

アーキテクチャコンポーネントフレームワークは、Androidアプリケーションを作成するための基礎となる一連のライブラリとガイドラインです。開発者が幅広いアプリケーションにわたって直面する一般的なシナリオに対処します。このフレームワークは、ボイラープレートと反復コードの量を減らし、アプリケーションのコア機能に集中することを目指しています。

アーキテクチャコンポーネントの基本ブロックには、次のものがあります。

- `Room` - SQLiteオブジェクトマッパー。 ORMliteやgreenDAOなどの他のライブラリと非常によく似ています。これはSQLを使用しており、依然としてクエリに対してコンパイル時間の保証が可能です。
- `LiveData` - ライフサイクルを意識した観測可能なコアコンポーネント。
- `ViewModel` - アクティビティ/フラグメントのためのアプリケーションの残りの部分との通信ポイント。それらはUIコードなしで、アクティビティやフラグメントよりも長持ちします。
- `Lifecycle` - アーキテクチャコンポーネントの中核部分であり、コンポーネント（アクティビティなど）のライフサイクル状態に関する情報が含まれています。
- `LifecycleOwner` - ライフサイクル（アクティビティ、フラグメント、プロセス、カスタムコンポーネント）を持つコンポーネントのコアインタフェース。
- `LifecycleObserver` - 特定のLifecycleメソッドがトリガされたときに何が起きるかを指定します。 LifecycleObserverを作成すると、コンポーネントを自己完結型にすることができます。

## Roomとは何か？

ルームはAndroidアプリでデータベースを作成する新しい方法です。 `Room`には、アプリケーションにデータを保存するために事前に書かなければならない定型コードがたくさんあります。 `Room`はJavaクラスとSQLiteの間のORMです。 `Room`では、もはやカーソルとローダーを使用する必要はありません。 `Room`は本格的なORMではありません。たとえば、他のORMソリューションが提供するような複雑なオブジェクトのネストを行うことはできません。

`Room`では、データを照会できるいくつかの方法があります。

- LiveDataは、更新を受け取るために登録できるイベントのストリームを公開するクラスです。 これは非同期であるため、メインスレッドで使用できます。
- RxJava2 Flowable抽象クラスを使用します。
- AsyncTaskなどのバックグラウンドスレッドに同期呼び出しを配置します。 （`Room`では、メインスレッドでデータベースクエリを発行することはできません（ANRsを生成できるため）。

## LiveDataとは何か？

`LiveData`を使用すると、明示的で堅固な依存関係のパスを作成せずに、アプリケーションの複数のコンポーネントにわたるデータの変更を監視できます。 `LiveData`は、アクティビティとフラグメントのさまざまなライフサイクルを尊重します。 `LiveData`と`Room`を組み合わせると、標準のSQLiteDatabaseを使用するだけでは達成できない自動データベース更新を受け取ることができます。

## In Summary

`Room`はAndroid上でSQLiteの実装をラップする使いやすいライブラリです。 また、カーソルやコンテンツプロバイダの代わりにオブジェクトを扱うための直観的なインターフェイスも提供します。 `LiveData`で`Room`を使用することは、革命です。 これは、標準のSQLiteDatabaseで達成するのが難しい可能性があるデータ変更についてのビューを通知することを許可します。

アクティビティやフラグメントに直接データをロードすることにはいくつかの落とし穴があります。 主な問題は、あなたのアクティビティやフラグメントがデータベースに緊密に結合していることです。 これは、`テストを追加したり、別の場所でロジックを再利用したりする場合には適していません`。 データベースロジックをビューロジックから分離する方がはるかに良い方法です。 ViewModelアーキテクチャコンポーネントは、この問題を解決することを目的としています。 
